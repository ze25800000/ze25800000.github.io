<!doctype html>
<html lang="en">
    <head>
		
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="">
        <link rel="shortcut icon" href="http://p0mvyl5ro.bkt.clouddn.com/timg%20%281%29.gif"/>
        <link rel="canonical" href="http://guolinn.com/">
        <link rel="alternate" type="application/rss+xml" title="Zia Yang" href="">
        <title>JavaScript语言精粹 | 超频散热</title>
        <meta name="description" content="{{meta_description}}">

        <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/styles/crisp.css">
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    </head>
    
		<body class="post-template">
	

        <header id="header">
            <a id="logo" href="/"><img src="http://p0mvyl5ro.bkt.clouddn.com/timg%20%281%29.gif" alt="超频散热" /></a>
            <h1><a href="/">Zia Yang</a></h1>
            <p>学习笔记</p>
            <div id="follow-icons">
          <a href="http://github.com/ze25800000"><i class="fa fa-github-square fa-2x"></i></a>
          <a href="http://twitter.com/YzzzzzzE"><i class="fa fa-twitter-square fa-2x"></i></a>
      </div>
<h6><a href="/about">About</a></h6>
        </header>

        <main id="content">
        

<article class="post">
  一月 3, 2017
  
    <span class="taglist">  &middot; 
    
    
      <a href='/tags/javascript/'>javascript</a> 
    
    </span>
  

  <h1 class="post-title">JavaScript语言精粹</h1>
  <section class="post-content article-entry">
    <h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><hr>
<ul>
<li>使用<code>Object.hasOwnProperty()</code>检测属性名是否为对象的成员,还是原型链的成员<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 1, b: 2, c: 3</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__.d = 4;</span><br><span class="line"></span><br><span class="line">for (i in obj) &#123;</span><br><span class="line">    console.log(i);//a,b,c,d</span><br><span class="line">    console.log(obj.hasOwnProperty(i));//true,true,true,false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><code>try</code>语句执行一个代码块,并捕获该代码块抛出的任何异常,<code>catch</code>从语句定义了一个新的变量,它将接受异常对象.<blockquote>
<ol>
<li>try 语句测试代码块的错误。</li>
<li>catch 语句处理错误。</li>
<li>throw 语句创建自定义错误。</li>
</ol>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function message() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        adddlert(&quot;Welcome guest!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (e) &#123;</span><br><span class="line">        txt = &quot;本页有一个错误。\n\n&quot;;</span><br><span class="line">        txt += &quot;错误描述：&quot; + e.message + &quot;\n\n&quot;;</span><br><span class="line">        txt += &quot;点击确定继续。\n\n&quot;;</span><br><span class="line">        alert(txt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p><code>typeof</code>运算符产生的值有<code>number</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code>、<code>function</code>、<code>object</code>。如果运算数是一个数组或者<code>null</code>,其反正值为<code>Object</code></p>
</blockquote>
<blockquote>
<p><code>+</code>运算符可以进行加法运算或字符串连接.如果你想要的是加法运算,请确保两个运算数都是数字.</p>
</blockquote>
<blockquote>
<p><code>/</code>运算符可能会产生一个非整数结果,即使两个运算数都是整数.</p>
</blockquote>
<hr>
<ul>
<li>JavaScript基本数据类型包括：数值、字符串、布尔值、<code>null</code>和<code>undefined</code>，其它的所有值为对象。字符串、布尔值和数值‘貌似’是对象，因为他们都有方法，但他们是不可变得。JavaScript中的对象是可变的键控对象，数组、函数、正则表达式都是对象，当然对象object更是对象。</li>
<li><code>||</code>运算符可以用来填充默认值:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var middle = stooge[&quot;middle-name&quot;] || &quot;(none)&quot;;</span><br><span class="line">var status = flight.status || &quot;unknown&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><code>typeof</code>会检测原型链</li>
<li><code>hasOwnProperty()</code>不检测原型链</li>
</ol>
<hr>
<h3 id="apply调用模式"><a href="#apply调用模式" class="headerlink" title="apply调用模式"></a><code>apply</code>调用模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Que = function (string) &#123;</span><br><span class="line">    this.status = string;</span><br><span class="line">&#125;;</span><br><span class="line">Que.prototype.get_status = function () &#123;</span><br><span class="line">    return this.status;</span><br><span class="line">&#125;;</span><br><span class="line">var statusObject = &#123;</span><br><span class="line">    status:&apos;A-OK&apos;</span><br><span class="line">&#125;;</span><br><span class="line">//statusObject上没有get_status方法,但可以继承Que的get_status</span><br><span class="line">var x = Que.prototype.get_status.apply(statusObject);</span><br><span class="line">console.log(x);//A-OK</span><br></pre></td></tr></table></figure>
<p><code>apply</code>将<code>get_status()</code>的<code>this</code>指向<code>statusObject</code></p>
<hr>
<h3 id="参数arguments"><a href="#参数arguments" class="headerlink" title="参数arguments"></a>参数arguments</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var sum = function () &#123;</span><br><span class="line">    var sum = 0, i;</span><br><span class="line">    for (i=0;i&lt;arguments.length;i+=1) &#123;</span><br><span class="line">        sum += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(sum(1,2,3,4));//10</span><br></pre></td></tr></table></figure>
<!--
### return返回
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Fn = function () &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;;</span><br><span class="line">    var a = Fn();</span><br><span class="line">    console.log(a);//undefined</span><br><span class="line">    var b = new Fn();</span><br><span class="line">    console.log(b);//Fn函数</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果函数以在前面加上 new前缀的方式来调用,且返回值不是一个对象,则返回this(该新对象)–&gt;</p>
</blockquote>
<hr>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    if (typeof a !== &apos;number&apos; || typeof b !== &apos;number&apos;) &#123;</span><br><span class="line">        throw &#123;</span><br><span class="line">            name: &apos;TypeError&apos;,</span><br><span class="line">            message: &apos;add needs numbers&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">var try_it = function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        add(&apos;seven&apos;);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        document.write(e.name + &apos;:&apos; + e.message);//TypeError:add needs numbers</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">try_it();</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="给类型添加方法"><a href="#给类型添加方法" class="headerlink" title="给类型添加方法"></a>给类型添加方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method = function (name, func) &#123;</span><br><span class="line">    this.prototype[name] = func;</span><br><span class="line">    return this;</span><br><span class="line">&#125;;</span><br><span class="line">Number.method(&apos;integer&apos;, function () &#123;</span><br><span class="line">    return Math[this &lt; 0 ? &apos;ceil&apos; : &apos;floor&apos;](this);</span><br><span class="line">&#125;);</span><br><span class="line">console.log((-10/3).integer());</span><br><span class="line"></span><br><span class="line">String.method(&apos;trimx&apos;, function () &#123;</span><br><span class="line">    return this.replace(/^\s+|\s+$/g, &apos;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;  12  &apos;.trimx());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基本类型的原型是公共结构,所以在类库混用时务必小心.一个保险的做法就是只在确定没有该方法时才添加它.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method = function (name, func) &#123;</span><br><span class="line">    if (!this.prototype[name]) &#123;</span><br><span class="line">        this.prototype[name] = func;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var walk_the_DOM = function walk(node, func) &#123;</span><br><span class="line">    func(node);</span><br><span class="line">    node = node.firstChild;</span><br><span class="line">    while (node) &#123;</span><br><span class="line">        walk(node, func);</span><br><span class="line">        node = node.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var getElementByAttribute = function (att, value) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    walk_the_DOM(document.body, function (node) &#123;</span><br><span class="line">        var actual = node.nodeType === 1 &amp;&amp; node.getAttribute(att);</span><br><span class="line">        if (typeof actual === &apos;string&apos; &amp;&amp; (actual === value || typeof value !== &apos;string&apos;)) &#123;</span><br><span class="line">            result.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(getElementByAttribute(&apos;class&apos;, &apos;11&apos;));</span><br></pre></td></tr></table></figure>
<p>尾递归<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn(i,a) &#123;</span><br><span class="line">    a = a || 1;</span><br><span class="line">    if (i&lt;2) &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(i - 1+&quot;&amp;&amp;&amp;&amp;&quot;+ i * a);</span><br><span class="line">    return fn(i - 1, i * a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">        value:0,</span><br><span class="line">        increment:function (inc) &#123;</span><br><span class="line">            this.value += typeof inc === &apos;number&apos; ? inc : 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>使用闭包可以保护value和increment不被修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myObject = function () &#123;</span><br><span class="line">    var value = 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        increment:function (inc) &#123;</span><br><span class="line">            value += typeof inc === &apos;number&apos; ? inc : 1;</span><br><span class="line">        &#125;,</span><br><span class="line">        getValue:function () &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<p>设置私有属性更有意义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var quo = function (status) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        get_status: function () &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">//构造一个quo(&apos;amazed&apos;)实例</span><br><span class="line">var myQuo = quo(&apos;amazed&apos;);</span><br><span class="line">console.log(myQuo);</span><br></pre></td></tr></table></figure></p>
<p>无需在前面加上new来使用,即使quo已经返回了,但get_status方法仍然享有访问quo对象的status属性的特权.</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fade = function (node) &#123;</span><br><span class="line">    var level = 1;</span><br><span class="line">    var step = function () &#123;</span><br><span class="line">        var hex = level.toString(16);</span><br><span class="line">        console.log(hex);</span><br><span class="line">        node.style.backgroundColor = &apos;#ffff&apos; + hex + hex;</span><br><span class="line">        if (level &lt; 15) &#123;</span><br><span class="line">            level++;</span><br><span class="line">            setTimeout(step, 100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    setTimeout(step, 100);</span><br><span class="line">&#125;;</span><br><span class="line">fade(document.body);</span><br></pre></td></tr></table></figure>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块模式利用了函数作用域和闭包来创建绑定对象与私有成员的关联,在这个例子中,只有deentityify方法有权访问字符实体表这个数据对象.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method = function (name, func) &#123;</span><br><span class="line">    if (!this.prototype[name]) &#123;</span><br><span class="line">        return this.prototype[name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">String.method(&apos;deentityify&apos;, function () &#123;</span><br><span class="line">    var entity = &#123;</span><br><span class="line">        quot: &apos;&quot;&apos;,</span><br><span class="line">        lt: &apos;&lt;&apos;,</span><br><span class="line">        gt: &apos;&gt;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return this.replace(/&amp;([^&amp;;]+);/g, function (a, b) &#123;</span><br><span class="line">            var r = entity[b];</span><br><span class="line">            return typeof r === &apos;string&apos; ? r : a;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br><span class="line">console.log(&apos;&amp;lt;&amp;quot;&amp;gt;&apos;.deentityify());</span><br></pre></td></tr></table></figure></p>
<p>模块模式的一般形式是:一个定义了私有变量和函数的函数;利用闭包创建可以访问私有变量和函数的特权函数;最后返回这个特权函数,或者把他们保存到一个可访问到的地方.</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var serial_maker = function () &#123;</span><br><span class="line">    var prefix = &apos;&apos;;</span><br><span class="line">    var seq = 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        set_prefix: function (p) &#123;</span><br><span class="line">            prefix = String(p);</span><br><span class="line">        &#125;,</span><br><span class="line">        set_seq: function (s) &#123;</span><br><span class="line">            seq = s;</span><br><span class="line">        &#125;,</span><br><span class="line">        gensym: function () &#123;</span><br><span class="line">            var result = prefix + seq;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">var seqer = serial_maker();</span><br><span class="line">seqer.set_prefix(&apos;Q&apos;);</span><br><span class="line">seqer.set_seq(1000);</span><br><span class="line">var unique = seqer.gensym();</span><br><span class="line">console.log(unique);//Q1000</span><br><span class="line">/*************************************************/</span><br><span class="line">seqer.set_name = function () &#123;</span><br><span class="line">        console.log(prefix);//prefix无法访问到</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>seqer对象是可变的,所以他的方法可能会被替换掉,但是替换后的方法不能访问私有成员,seqer就是一组函数的集合,而且那些函数被授予特权,拥有使.用或修改私有状态的能力.</p>
<h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p>函数可以用对象去记忆先前操作的结果,从而能避免无谓的运算<br><br>没有使用记忆的demo如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fibonacci = function (n) &#123;</span><br><span class="line">    return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">&#125;;</span><br><span class="line">for (var i=0;i&lt;=10;i++) &#123;</span><br><span class="line">    console.log(i + &quot; : &quot; + fibonacci(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用记忆的demo如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var fibonacci=function () &#123;</span><br><span class="line">    var memo = [0, 1];</span><br><span class="line">    var fib = function (n) &#123;</span><br><span class="line">        var result = memo[n];</span><br><span class="line">        //当result为undefined的时候,向数组中添加数据</span><br><span class="line">        if (typeof result!==&apos;number&apos;) &#123;</span><br><span class="line">            result = fib(n - 1) + fib(n - 2);</span><br><span class="line">            memo[n] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    return fib;</span><br><span class="line">&#125;();</span><br><span class="line">for (var i=0;i&lt;=10;i++) &#123;</span><br><span class="line">    document.writeln(i + &quot; : &quot; + fibonacci(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用回调函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//通过声明fibonacci,执行第一遍memoizer,于是fibonacci=function(n)&#123;..&#125;,</span><br><span class="line"></span><br><span class="line">    var memoizer = function (memo, fundamental) &#123;</span><br><span class="line">        var shell = function (n) &#123;</span><br><span class="line">            var result = memo[n];</span><br><span class="line">            if (typeof result !== &apos;number&apos;) &#123;</span><br><span class="line">                result = fundamental(shell, n);</span><br><span class="line">                memo[n] = result;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;;</span><br><span class="line">        return shell;</span><br><span class="line">    &#125;;</span><br><span class="line">    var fibonacci = memoizer([0, 1], function (shell, n) &#123;</span><br><span class="line">        return shell(n - 1) + shell(n - 2);</span><br><span class="line">    &#125;);</span><br><span class="line">    for (var i=0;i&lt;=10;i++) &#123;</span><br><span class="line">        console.log(i + &quot; : &quot; + fibonacci(i));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用回调函数可以设计出其他函数的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fibonacci = memoizer([1, 1], function (shell, n) &#123;</span><br><span class="line">    return n * shell(n - 1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li><p>定义一个构造器并扩充它的原型:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Mammal = function (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Mammal.prototype.get_name = function () &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">Mammal.prototype.says = function () &#123;</span><br><span class="line">    return this.saying || &apos;&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造一个实例</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myMammal = new Mammal(&apos;Herb the Mammal&apos;);</span><br><span class="line">var name = myMammal.get_name();//&apos;Herb the Mammal&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造另一个伪类来继承Mammal,这是通过定义它的constructor函数并替换它的prototype为一个Mammal的实例来实现的:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Cat = function (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.saying = &apos;meow&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//替换Cat.prototype为一个新的Mammal实例</span><br><span class="line">Cat.prototype = new Mammal();</span><br><span class="line">//扩充新原型对象,增加purr和get_name方法.</span><br><span class="line">Cat.prototype.purr = function (n) &#123;</span><br><span class="line">    var i, s = &apos;&apos;;</span><br><span class="line">    for (i = 0; i &lt; n; i += 1) &#123;</span><br><span class="line">        if (s) &#123;</span><br><span class="line">            s += &apos;-&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        s += &apos;r&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;;</span><br><span class="line">Cat.prototype.get_name = function () &#123;</span><br><span class="line">    return this.says() + &apos;  &apos; + this.name + &apos;  &apos; + this.says();</span><br><span class="line">&#125;;</span><br><span class="line">var myCat = new Cat(&apos;Henrietta&apos;);</span><br><span class="line">var says = myCat.says();//&apos;meow&apos;</span><br><span class="line">var purr = myCat.purr(5);//&apos;r-r-r-r-r</span><br><span class="line">var name = myCat.get_name();//&apos;meow  Henrietta  meow&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>使用method方法定义一个inherits方法:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method = function (name, func) &#123;</span><br><span class="line">    if (!this.prototype[name]) &#123;</span><br><span class="line">        return this.prototype[name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>inherits和method方法都返回this,这将允许我们可以以级联的样式编程.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.method(&apos;inherits&apos;, function (Parent) &#123;</span><br><span class="line">    this.prototype = new Parent();</span><br><span class="line">    return this;</span><br><span class="line">&#125;);</span><br><span class="line">Function.method(&apos;inherits&apos;, function (Parent) &#123;</span><br><span class="line">        this.prototype = new Parent();</span><br><span class="line">        return this;</span><br><span class="line">    &#125;);</span><br><span class="line">    var Cat = function (name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.saying = &apos;meow&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">        .inherits(Mammal)</span><br><span class="line">        .method(&apos;purr&apos;, function (n) &#123;</span><br><span class="line">            var i, s = &apos;&apos;;</span><br><span class="line">            for (i = 0; i &lt; n; i += 1) &#123;</span><br><span class="line">                if (s) &#123;</span><br><span class="line">                    s += &apos;-&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">                s += &apos;r&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;)</span><br><span class="line">        .method(&apos;get_name&apos;, function () &#123;</span><br><span class="line">            return this.says() + &apos;  &apos; + this.name + &apos;  &apos; + this.says();</span><br><span class="line">        &#125;);</span><br><span class="line">    console.log(new Cat(&quot;你他妈在耍老子&quot;));</span><br></pre></td></tr></table></figure>
<p>这种方法没有私有环境;所有的属性都是公开的,没有访问父类的方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//判断Object中有没有beget方法</span><br><span class="line">if (typeof Object.beget!==&apos;function&apos;) &#123;</span><br><span class="line">    Object.beget = function (o) &#123;</span><br><span class="line">        //创建函数F</span><br><span class="line">        var F = function () &#123;&#125;;</span><br><span class="line">        //向函数F的原型覆盖为对象o</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        //实例化一个F对象</span><br><span class="line">        return new F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var myMammal = &#123;</span><br><span class="line">    name: &apos;Herb the Mammal&apos;,</span><br><span class="line">    get_name: function () &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    says: function () &#123;</span><br><span class="line">        return this.saying || &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var myCat = Object.beget(myMammal);</span><br><span class="line">myCat.name = &apos;Henrietta&apos;;</span><br><span class="line">myCat.purr = function (n) &#123;</span><br><span class="line">    var i, s = &apos;&apos;;</span><br><span class="line">    for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (s) &#123;</span><br><span class="line">            s += &apos;-&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        s += &apos;r&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;;</span><br><span class="line">myCat.get_name = function () &#123;</span><br><span class="line">    return this.says + &apos; &apos; + this.name + &apos; &apos; + this.says;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一种”差异化继承”.通过定制一个新的对象,我们指明了它与所基于的基本对象的区别.</p>
<h3 id="函数化"><a href="#函数化" class="headerlink" title="函数化"></a>函数化</h3><p>以上的继承模式的一个弱点就是我们没法保护隐私.对象的所有属性都是可见的. 我们从构造以个将产生对象的函数开始,给他起的名字讲义一个小写字母开头,因为他并不需要使用new前缀.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var mammal = function (spec) &#123;</span><br><span class="line">    var that = &#123;&#125;;</span><br><span class="line">    that.get_name = function () &#123;</span><br><span class="line">        return spec.name;</span><br><span class="line">    &#125;;</span><br><span class="line">    that.says = function () &#123;</span><br><span class="line">        return spec.saying || &apos;&apos;;</span><br><span class="line">    &#125;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;;</span><br><span class="line">var myMammal = mammal(&#123;name: &apos;Herb&apos;&#125;);</span><br><span class="line"></span><br><span class="line">var cat = function (spec) &#123;</span><br><span class="line">    spec.saying = spec.saying || &apos;meow&apos;;</span><br><span class="line">    var that = mammal(spec);</span><br><span class="line">    that.purr = function (n) &#123;</span><br><span class="line">        var i, s = &apos;&apos;;</span><br><span class="line">        for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (s) &#123;</span><br><span class="line">                s += &apos;_&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            s += &apos;r&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;;</span><br><span class="line">    that.get_name = function () &#123;</span><br><span class="line">        return that.says() + &apos; &apos; + spec.name + &apos; &apos; + that.says();</span><br><span class="line">    &#125;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;;</span><br><span class="line">var myCat = cat(&#123;name: &apos;Henrietta&apos;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>函数化模式还给我们提供了一个处理父类方法的方法.我们将构造一个superior方法,它取得一个方法名并返回调用那个方法的函数.该函数将调用原来的方法,尽管属性已经变化了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object.method(&apos;superior&apos;, function (name) &#123;</span><br><span class="line">    var that = this,</span><br><span class="line">        //把之前对象里的方法 传给method</span><br><span class="line">        method = that[name];</span><br><span class="line">    return function () &#123;</span><br><span class="line">        //返回这个方法 ,并且这个方法指向调用者</span><br><span class="line">        //return method();</span><br><span class="line">        return method.apply(that, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>把调用superior方法的结果返回给它.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var coolcat = function (spec) &#123;</span><br><span class="line">    var that = cat(spec),</span><br><span class="line">        super_get_name = that.superior(&apos;get_name&apos;);</span><br><span class="line">    console.log(that.superior(&apos;get_name&apos;)());</span><br><span class="line">    that.get_name = function () &#123;</span><br><span class="line">        return &apos;like &apos; + super_get_name() + &apos; body&apos;;</span><br><span class="line">    &#125;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;;</span><br><span class="line">var myCoolCat = coolcat(&#123;name: &apos;Bix&apos;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>函数化模式有很大的灵活性.不仅不像伪类模式那样需要很多功夫,还让我们更好的封装和信息隐藏,以及访问父类的方法的能力.<br>如果我们用函数化得样式创建一个对象,并且该对象的所有方法都不使用this或that,那么该对象就是持久性的.一个持久性对象就是一个简单功能函数的集合.一个持久性的对象不会被损害.方为一个持久性的对象时,除非被方法授权,否则攻击者不能访问对象的内部状态.</p>
<h3 id="给数组添加方法"><a href="#给数组添加方法" class="headerlink" title="给数组添加方法"></a>给数组添加方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method = function (name, func) &#123;</span><br><span class="line">    if (!this.prototype[name]) &#123;</span><br><span class="line">        return this.prototype[name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Array.method(&apos;reduce&apos;, function (f, value) &#123;</span><br><span class="line">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        value = f(this[i], value);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;);</span><br><span class="line">//创建一个数字数组</span><br><span class="line">var data = [1,2,3,4,5,6,7,8,9,10];</span><br><span class="line">//定义两个简单函数.一个是将两个数字相加.另一个是将两个数字相乘.</span><br><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">var mult = function (a, b) &#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;;</span><br><span class="line">//调用data的reduce方法,传入add函数.</span><br><span class="line">var sum = data.reduce(add, 0);</span><br><span class="line">//再次调用reduce方法,这次传入mult函数.</span><br><span class="line">var product = data.reduce(mult, 1);</span><br><span class="line">console.log(sum)</span><br></pre></td></tr></table></figure>
<p>由于数组是对象,所以我们可以给一个单独的数组添加方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data.total = function () &#123;</span><br><span class="line">    return this.reduce(add, 0);</span><br><span class="line">&#125;;</span><br><span class="line">total = data.total();</span><br></pre></td></tr></table></figure></p>
<h3 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h3><p>假如实现的算法是假设从一个已知的值开始,那么必须自己准备好这个数组.<br>给Array中添加dim方法创建初始化数组.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.dim = function (dimension, initial) &#123;</span><br><span class="line">    var a = [], i;</span><br><span class="line">    for (i = 0; i &lt; dimension; i++) &#123;</span><br><span class="line">        a[i] = initial;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;;</span><br><span class="line">//创建一个包含10个0的数组</span><br><span class="line">var myArray = Array.dim(10, 0);</span><br><span class="line">console.log(myArray)</span><br></pre></td></tr></table></figure></p>
<p>Array中添加方法,创建多维数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.matrix = function (m, n, initial) &#123;</span><br><span class="line">        var a, i, j, mat = [];</span><br><span class="line">        for (i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            a = [];</span><br><span class="line">            for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                a[j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            mat[i] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        return mat;</span><br><span class="line">    &#125;;</span><br><span class="line">    var myMatrix = Array.matrix(4, 4, 0);</span><br></pre></td></tr></table></figure></p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var parse_url=/^(?:([A-Za-z]+):)?(\/&#123;0,3&#125;)([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;</span><br></pre></td></tr></table></figure>
<ul>
<li>^ 代表开始的位置,为了防止exec跳过不想URL的前缀</li>
<li>(?:…)表示一个非捕获型分组, (?:([A-Za-z]+):)?最后一个?,表示这个分组是可选的,它表示重复0或1次</li>
<li>(…)表示一个捕获型分组(会带来性能上的损失).一个捕获型分组复制它所匹配的文本,并将其放入result数组中.</li>
<li>(\/{0,3})用来匹配//</li>
<li>([0-9.-A-Za-z]+)用来匹配主机名,\- 用\来转义-,防止与表示范围的连字符-混淆</li>
<li>(?::(\d+))?用来匹配端口号</li>
<li>(?:\/([^?#]*))? 表示除了?和#号以外的所有字符都会捕获</li>
<li>(?:\?([^#]*))? 匹配0个或多个非#号字符</li>
<li>(?:#(.*))? .可以匹配一切字符,除了\n\t \u2028 结束符$</li>
<li>$ 表示这个字符串的结束.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var url = &quot;http://www.baidu.com:80/goodpartts?q#fragment&quot;;</span><br><span class="line">var result = parse_url.exec(url);</span><br><span class="line">/**</span><br><span class="line"> * 0 : &quot;http://www.baidu.com:80/goodpartts?q#fragment&quot;</span><br><span class="line"> * 1 : &quot;http&quot;</span><br><span class="line"> * 2 : &quot;//&quot;</span><br><span class="line"> * 3 : &quot;www.baidu.com&quot;</span><br><span class="line"> * 4 : &quot;80&quot;</span><br><span class="line"> * 5 : &quot;goodpartts&quot;</span><br><span class="line"> * 6 : &quot;q&quot;</span><br><span class="line"> * 7 : &quot;fragment&quot;</span><br><span class="line"> * */</span><br><span class="line">var names = [&apos;url&apos;, &apos;scheme&apos;, &apos;slash&apos;, &apos;host&apos;, &apos;port&apos;, &apos;path&apos;, &apos;query&apos;, &apos;hash&apos;];</span><br><span class="line">for (var i=0;i&lt;names.length;i++) &#123;</span><br><span class="line">    document.writeln(names[i] + &apos;  :  &apos; + result[i]+&apos;&lt;br&gt;&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>url :  <a href="http://www.baidu.com:80/goodpartts?q#fragment">http://www.baidu.com:80/goodpartts?q#fragment</a></p>
</blockquote>
<blockquote>
<p>scheme :  http</p>
</blockquote>
<blockquote>
<p>slash :  //</p>
</blockquote>
<blockquote>
<p>host :  <a href="http://www.baidu.com">www.baidu.com</a></p>
</blockquote>
<blockquote>
<p>port :  80</p>
</blockquote>
<blockquote>
<p>path :  goodpartts</p>
</blockquote>
<blockquote>
<p>query :  q</p>
</blockquote>
<blockquote>
<p>hash :  fragment</p>
</blockquote>
<hr>
<p><code>&#39;into&#39;.match(/in|int/)</code>将在into中匹配in.但它不会匹配int,因为in已经匹配成功了.</p>
-->
  </section>
  <footer class="post-footer">
    <!--
    <section class="author">
      <h4>Zia Yang</h4>
      <p></p>
    </section>
    -->
  </footer>
</article>

<nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/2017/01/04/node学习笔记/">
        ← prev <!--node学习笔记-->
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2017/01/01/typescript/">
        <!--typescript学习笔记--> next →
    </a>
    
</nav>


        </main>
        <footer id="footer">
            <section id="footer-message">&copy; 2018 Zia Yang. All rights reserved. Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. <a href="https://github.com/guolin/crisp-hexo-theme" target="_blank">crisp</a> theme by <a href="guolin.github.io" target="_blank">Guo Lin</a>.</section>
        </footer>
    </body>
</html>


